import { HttpParams } from '@angular/common/http';
import { Component, effect, inject, OnDestroy, untracked, ViewEncapsulation } from '@angular/core';
import { FormArray, FormControl, FormGroup } from '@angular/forms';
import { AttachmentModel } from '@domain/lib/document-management';
import {
  PriceEstimateItemModel,
  PriceEstimateModel
} from '@domain/lib/purchase-and-orders';
import { ClDataTableComponent } from '@sadad/component-lib/src/lib/data-table';
import { ClDatePickerComponent } from '@sadad/component-lib/src/lib/date-picker';
import { ClFileUploadComponent } from '@sadad/component-lib/src/lib/file-uploader';
import { ClAction, ClConfirmation } from '@sadad/component-lib/src/models';
import { AttachmentFacade, OrderFacade, PriceEstimateFacade } from '@state/lib/facade';
import { BaseComponent, HeadingComponent } from '@view/lib/components';
import { ActionInvokeService } from '@view/lib/ui-services';
import { CommonModules, CONFIRMATION_SERVICE_CONFIG } from '@view/lib/values';
import { Subject, takeUntil } from 'rxjs';

@Component({
  selector: 'purchase-price-estimate',
  standalone: true,
  imports: [CommonModules, HeadingComponent, ClDatePickerComponent, ClDataTableComponent, ClFileUploadComponent],
  templateUrl: './price-estimate.component.html',
  encapsulation: ViewEncapsulation.None,
  styles: `
  .price-estimate-attachments cl-file-uploader .cl-file-uploader-buttonbar cl-button:nth-of-type(2) { display: none }`,
  providers: []
})
export class PriceEstimateComponent extends BaseComponent<PriceEstimateModel> implements OnDestroy {
  readonly priceEstimateFacade = inject(PriceEstimateFacade);
  readonly orderFacade = inject(OrderFacade);
  readonly attachmentFacade = inject(AttachmentFacade);
  readonly confirmationConfig = inject<ClConfirmation>(CONFIRMATION_SERVICE_CONFIG);
  readonly #invokeService = inject(ActionInvokeService);

  priceEstimate!: PriceEstimateModel;
  editMode = this.priceEstimateFacade.priceEstimateStore.state$().editMode$();
  destroyer = new Subject<void>();
  deletingAttachmentId!: string;
  totalPriceForm = new FormGroup({
    totalPrice: new FormControl(0),
    attachedFiles: new FormControl
  })

  get priceEstimateItems(): FormArray {
    return this.formGroup.get('priceEstimateItems') as FormArray
  }

  constructor() {
    super();

    effect(() => {
      const orderId = this.orderFacade.orderStore.state$().selectedOrder$().id;
      untracked(() => {
        if (orderId) {
          this.priceEstimateFacade.getPriceEstimateByOrderId(orderId);
        }
      })
    });

    effect(() => {
      this.priceEstimate = this.priceEstimateFacade.priceEstimateStore.state$().SelectedPriceEstimate$();
      untracked(() => {
        if (this.priceEstimate) {
          this.formGroup = new FormGroup({
            autoGeneratedCode: new FormControl(this.priceEstimate.autoGeneratedCode),
            date: new FormControl(this.priceEstimate.date || new Date()),
            order: new FormControl(this.priceEstimate.order),
            priceEstimateItems: new FormArray(this.priceEstimate.priceEstimateItems?.map(each => this.addPriceEstimate(each)) || []),
          })
          this.totalPriceForm.controls['totalPrice']?.setValue(this.calculateTotalPrice(this.priceEstimate));
          this.totalPriceForm.controls['attachedFiles']?.setValue(this.priceEstimate.attachedFiles);
          this.onChangeForm();
        }
      })
    })

    this.destroyObservable(this.#invokeService.getMethodInvocation()).subscribe(
      () => {
        this.submit();
      }
    );
  }

  onChangeForm() {
    this.formGroup.valueChanges
      .pipe(takeUntil(this.destroyer))
      .subscribe((value) => {
        this.totalPriceForm.controls['totalPrice']?.setValue(this.calculateTotalPrice(value));
      });
  }


  calculateTotalPrice(value: PriceEstimateModel): number {
    return value.priceEstimateItems?.reduce((acc, each) =>
      Math.ceil(
        acc +
        (((each.goods?.remainingQuantity || 0) * (each.estimateFee || 0)) +
          (((each.taxPercent || 0) / 100) * ((each.goods?.remainingQuantity || 0) * (each.estimateFee || 0))) +
          (each.deductionsAmount || 0))
      )
      , 0) || 0;
  }

  addPriceEstimate(estimate: PriceEstimateItemModel): FormGroup {
    return new FormGroup({
      estimateFee: new FormControl(estimate.estimateFee),
      taxPercent: new FormControl(estimate.taxPercent),
      deductionsAmount: new FormControl(estimate.deductionsAmount),
      description: new FormControl(estimate.description),
      goods: new FormControl(estimate.goods)
    });
  }

  submit() {
    this.priceEstimateFacade.savePriceEstimate({
      ...this.formGroup.value,
      attachedFiles: this.totalPriceForm.get('attachedFiles')?.value
    });
  }

  deleteAttachment(event: { action: ClAction, row: AttachmentModel }) {
    this.deletingAttachmentId = event.row.id ?? '';
    if (event.action.key == 'download') {
      this.attachmentFacade.downloadFileById(event.row);
    }
  }

  deleteFileHttpParams() {
    return new HttpParams().set('attachmentId', this.deletingAttachmentId);
  }

  ngOnDestroy(): void {
    this.destroyer.next();
    this.destroyer.complete();
  }

}
